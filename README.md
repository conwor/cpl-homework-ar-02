# Лабораторная №2 - Реализация динамического массива макросами

Реализуйте с помощью function-like макросов, параметризованных треми параметрами `T`, `NAME` и
`DEFUALT_CAP`, шаблон структуры динамического массива произвольного типа. Параметр `T` определяет
тип элемента, `NAME` - имя структуры, `DEFUALT_CAP` - начальную ёмкость по умолчанию.

Реализация должна включать, как минимум, следующие функции:

* `void NAME##_init(NAME* arr)` - инициализация массива, созданного в произвольной памяти, с
  начальной ёмкостью `DEFUALT_CAP`
* `void NAME##_deinit(NAME* arr)` - деинициализация массива, не удаляющая его
* `NAME* new_##NAME()` - создание нового массива в динамической памяти и инициализация его с
  начальной ёмкостью `DEFUALT_CAP`
* `void delete_##NAME(NAME* arr)` - деинициализация массива и удаление его, полагающееся на то, что
  он был создан в динамической памяти
* `void NAME##_ensure_capacity(NAME* arr, size_t required_cap)` - функция, гарантирующая ёмкость не
  меньше чем `required_cap`
* `void NAME##_add_tail(NAME* arr, T elem)` - добавление элемента `elem` в конец массива
* `void NAME##_fill(NAME* arr, size_t count, T filler)` - добавление `count` элементов `filler` в
  конец массива
* `T NAME##_del_tail(NAME* arr)` - удаление элемента с конца массива (возвращает удалённый элемент)
* `T NAME##_get(NAME* arr, size_t index)` - возврат элемент по индексу
* `T NAME##_get_or(NAME* arr, size_t index, T default)` - возврат элемент по индексу, либо
  `defailt`, если индекс не входит в пределы массива
* `void NAME##_set(NAME* arr, size_t index, T elem)` - изменение элемента по индексу
* `T NAME##_del(NAME* arr, size_t index)` - удаление элемента по индексу

## Тестирование

Для проверки работоспособности массива возьмите ваше решение лабораторной №1 (Частотный словарь
английского языка) и используйте в ней массив дважды:
* Для хранения символов при чтении слов из входного потока
* Для хранения пар слов и количества их вхождений

Поправленное решение должно проходить те же самые тесты (в этом задании приложены аналогичные тем,
которые были в лабораторной №1).

## Дальнейшее использование

Условием всех дальнейших лабораторных является использование шаблонного динамического массива,
который вы создадите в рамках этого задания, вместо любых эквивалентных конструкций. Добавляйте
произвольный необходимый вам функционал, но следите за тем, чтобы массив оставался независимым
от типа элемента, к которому он применяется.

## Пример

### Входные данные

```
Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
```

### Выходные данные

```
buffalo: 8 (100.00 %)

```
